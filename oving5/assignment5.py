# -*- coding: utf-8 -*-
"""Assignment5.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/141obMsqOx5b7O1FJtygf0x3WEgkssl79

# Assignment #5

Hash Tables in Python


In this assignment, you will create Python dictionaries from scratch using a data structure called hash table. For example, here's a dictionary for storing and retrieving phone numbers using people's numbers.
"""

phone_numbers = {
  '3316412003': 'Waqar Bilal',
'3033226026': 'Hamza Zia',
'3032217073': 'Abid Zahid'
}
phone_numbers

"""**Part 1**: Your objective in this assignment is to implement a “My_HashTable class” that supports the following operations:

•	Insert: Insert a new key-value pair

•	Search: Find the value associated with a key

•	Update: Update the value associated with a key

•	display_all: List all the keys stored in the hash table

Complete the hash table implementation below by following the instructions in the comments.

 (30 p)
"""

class MyHashTable:
    def __init__(self):

        # 1. Create a list of size `list_size` with all values None
        self.max_size = 4096
        self.liste = [None]*self.max_size

    def get_hash(self,key):    
        sum = 0
        for i in range(len(key)):
            sum = sum + ord(key[i])
        return sum


    def get_index(self, key):
        sum = self.get_hash(key)
        return sum % self.max_size


    def insert(self, key, value):
        # 1. Find the index for the key using get_index
        index = self.get_index(key)
         
        # 2. Store the key-value pair at the right index
        self.liste[index] = value    

    def search(self, key):
        # 1. Find the index for the key using get_index
        index = self.get_index(key)

        # 2. Retrieve the data stored at the index
        data = self.liste[index]

        # 3. Return the value if found, else return None
        return data


    def update(self, key, value):
        # 1. Find the index for the key using get_index
        index = self.get_index(key)

        # 2. Store the new key-value pair at the right index
        self.liste[index] = value

    def display_all(self):
        # 1. Extract the key from each key-value pair
        for i in range(self.max_size):
            if self.liste[i] != None:
                print(f"{i}: {self.liste[i]} \n" )
        


"""**Part2:** Read the phonebook CSV file and store the key/value data in the hashtable object created in the “My_HashTable class”, hashtable size is : max_size =4096


* take phone column as the key
* take the name column as the value

 (10 p)
"""

# write your code here
newHashTable = MyHashTable()

with open('Phonebook.csv', 'r') as file:
    next(file)
    for object in file:
        if not object.strip().replace(',' , ''):
            continue

        values = object.strip().split(',')
        if len(values) > 3:
            phoneNumber = values[0]
            name = values[1]
            newHashTable.insert(phoneNumber, name)
    newHashTable.display_all()
    
print('__________________________________________________')


# """**Part 3:** try to add these two new data into the created hashtable:

# phone_number_1 = '123456789', name_1 = 'UiS'

newHashTable.insert("987654321", 'NTNU')

# phone_number_2 = '987654321', name_2 = 'NTNU'

newHashTable.insert('987654321', 'NTNU')


# •	Explain what happened there when you add the second number???
#The first value got overwritten :)
#  (10 p)



# """

# phone_number_1 = '123456789'
# name_1 = 'UiS'
newHashTable.insert('123456789','UiS')

# phone_number_2 = '987654321'
# name_2 = 'NTNU'
newHashTable.insert('987654321','NTNU')
newHashTable.display_all()
print("_______________________________________________________________")
print("________Probing Hash Table___________")


# """**Part 4:**
# Handling Collisions with Linear Probing: As you might have wondered, multiple keys can have the same hash.

# Data stored against one key may override the data stored against another, if they have the same hash.

# * So Define a function called get_valid_index, which starts searching the data list from the index determined by the hashing function get_index and returns the first index which is either empty or contains a key-value pair matching the given key. Here you implement the linear probing method to find the available slot and return the index.



# * now implement a hash table class with linear probing. You need to define a  "ProbingHashTable" class.
# * add get_valid_index function into the ProbingHashTable class

# * Implement all the operations for this class: Insert,Search,Update, display_all


#  (40 p)




# """

def get_valid_index(data_list, key):
    # Start with the index returned by get_index
    index = ProbingHashTable.get_index(key)
    return index

class ProbingHashTable:
    def __init__(self):

        # 1. Create a list of size `list_size` with all values None
        self.max_size = 4096
        self.liste = [None]*self.max_size

    def get_valid_index(self,key):
        index = self.get_index(key)
        while self.liste[index] is not None:
            index += 1
            if index > self.max_size-1:
                index = 0
        return index

    def get_hash(self,key):
        sum = 0
        for i in range(len(key)):
            sum = sum + ord(key[i])
        return sum

    def get_index(self, key):
        # Take the remainder of the result with the size of the data list and return the index of the list
        sum = self.get_hash(key)
        return sum % self.max_size

    def insert(self, key, value):
        # 1. Find the index for the key using get_index
        index = self.get_valid_index(key)

        # 2. Store the key-value pair at the right index
        self.liste[index] = value    


    def search(self, key):
        # 1. Find the index for the key using get_index
        index = self.get_valid_index(key)

        # 2. Retrieve the data stored at the index
        data = self.liste[index]

        # 3. Return the value if found, else return None
        return data

    def update(self, key, value):
        # 1. Find the index for the key using get_index
        index = self.get_valid_index(key)

        # 2. Store the new key-value pair at the right index
        self.liste[index] = value

    def display_all(self):
        # 1. Extract the key from each key-value pair
        for i in range(len(self.liste)):
            if self.liste[i] != None:
                print(f"{i} {self.liste[i]}")

# """read csv file and store the data into a hashtable object"""

# # write your code here
newProbingHasTable = ProbingHashTable()

with open('Phonebook.csv', 'r') as file:
    next(file)
    for object in file:
        if not object.strip().replace(',' , ''):
            continue

        values = object.strip().split(',')
        if len(values) > 3:
            phoneNumber = values[0]
            name = values[1]
            newProbingHasTable.insert(phoneNumber, name)
    newProbingHasTable.display_all()
        


# """Try to add two new numbers and test
#  (10 p)
# """

# phone_number_1 = '123456789'
# name_1 = 'UiS'
# phone_number_2 = '987654321'
# name_2 = 'NTNU'

# #insert the first key
newProbingHasTable.insert("123456789", "UiS")

# # Insert a colliding key
newProbingHasTable.insert("987654321", "NTNU")

# # Check the new and old keys
newProbingHasTable.display_all()
